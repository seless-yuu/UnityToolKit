
# アプリケーションアーキテクト

下記に意図するアプリケーションの設計を示します
全体像から順に記述します
また、プログラムは全てライブラリであるという考えに従います
コードはアプリケーションを記述したデータやスクリプトを受け取り動作します
開発するのはアプリケーションですが、上記の考えにより再利用できるコードを記述する事に努めます

## 前提

### 環境

#### Unityゲームエンジン上に作成

UnityゲームエンジンバージョンはUnity6以降を想定します
システムは原則C#で記述されます
必要であればプラグインとして他言語を使用しても構いません

#### アセット管理

ラベル、パッケージ化はAddressableAssetSystemを使用します

### 方針

#### 全てを自分で記述しない

有効なパッケージ、ライブラリがある場合は積極的に使用します
その場合は意図を伝え提案を行なって下さい

#### 生成AIフレンドリー

可能な限り生成AIフレンドリーとします
具体的にはテキストデータを主に扱います

#### ジェネレータツール

また、直接記述する必要はなくコードジェネレータツールを作成するのが
効率的ならばそちらを選択します
C#でのSourceGeneratorを中心にその他言語でのツール、アセットジェネレータ作成も
念頭に置きます

#### Monobehaviourとロジックコードは分離する

MonoBehaviourとロジックは分離して記述します
Unityのヒエラルキーツリーをシーングラフとその状態ツリーと考えます
MonoBehaviourは描画されるオブジェクトとその状態を保持します
原則ロジックは別階層で記述し、MonoBehaviourはそれを使用する方針とします
ただし、全てをそうする事も現実的ではありません
例えばアプリケーションのエントリポイントや常駐物は難しいと考えます
無理な設計となる場合はエンジン設計に従い、それ以外は可能な限り上記方針とします

#### アプリケーションレイヤーは原則コードとして記述しない

アプリケーションレイヤーはLua、状態遷移が複雑な場合はVisualScriptingで記述します
生成AIフレンドリーを考え、Lua実装を優先します
LuaインタープリタはUnityアセットを使用します

## 全体設計

アプリケーションは下記の要素で構成されます

### 場面管理

#### 場面切り替えの定義

・技術的にメモリ等の資源内にある内容を入れ替えざるを得ない
・プレイヤーの思考を切り替える必要があると判断された局面
上記に該当する場合に行う処理を場面切り替えとします
ただし、前者は極力避けるべきです
この考え方の為、Unityや一般的に言われるシーン機能には該当しません
シーンは一つのみ使用される事もあり得、シーン機能はこの場面切り替えの手段とします
例えば、オープンワールドゲームは極力一つの場面で動作します
全てがメモリに乗る規模のゲームならば前者は必要がないはずです

#### 場面切り替え手段

具体的な演出はアプリケーションが実装するのが望ましいですが
場面切り替えの定義によりフレーワークレベルで考慮しなければ対処が難しいと考えます
大別して以下が考えられます
